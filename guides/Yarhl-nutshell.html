<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Yarhl in a nutshell | SceneGate Yarhl </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Yarhl in a nutshell | SceneGate Yarhl ">
    <meta name="generator" content="docfx 2.56.7.0">
    
    <link rel="shortcut icon" href="../images/favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    <meta property="docfx:newtab" content="true">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../images/favicon-48.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                
                <ul class="nav level1 navbar-nav">
                      <li>
                          <a href="../index.html" title="Home">Home</a>
                      </li>
                      <li>
                          <a href="../guides/Yarhl-nutshell.html" title="Guides">Guides</a>
                      </li>
                      <li>
                          <a href="../dev/Changelog.html" title="API">API</a>
                      </li>
                      <li>
                          <a href="https://github.com/SceneGate/Yarhl" title="GitHub">GitHub</a>
                      </li>
                </ul>    </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Guides</a>
                        
                        <ul class="nav level2">
                          <li class="active">
                            <a href="Yarhl-nutshell.html" title="Yarhl in a nutshell" class="active">Yarhl in a nutshell</a>
                          </li>
                          <li class="">
                            <a href="Cookbook.html" title="Cookbook" class="">Cookbook</a>
                          </li>
                        </ul>  </li>
                    <li class="">
                      <span class="expand-stub"></span>
                      <a class="">Contributing</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="Contributing.html" title="Guidelines" class="">Guidelines</a>
                          </li>
                        </ul>  </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="yarhl-in-a-nutshell">Yarhl in a nutshell</h1>

<p><img src="../images/logo.png" alt="Yarhl Logo"></p>
<p><strong>Yarhl</strong> - <em>Yet Another ROM Hacking Library</em> - is a library for <em>ROM Hacking</em>
and fan-translation projects. It provides a virtual file system, file format,
and format conversion features and plugin support.</p>
<p>But what it really has to offer? Why should you use it? And how? This tutorial
will teach you how to use Yarhl and how to take advantage of the 100% of it.</p>
<p>Remember that if you have any question you can create GitHub issues, contact the
contributors by email, Twitter or Discord. But first make sure you've read the
whole docs.</p>
<h2 id="your-first-steps-reading-and-writing">Your first steps: Reading and Writing</h2>
<p>Oh, hi! I'm Mister Yarhl (or M.Y.). Nice to meet you. I will be your guide!
Erm... y-you can... picture me like this:</p>
<p><img src="../images/mister.png" alt="Mister Yarhl"></p>
<p>Let's get started! The first module I'm teaching you is
<a class="xref" href="../api/Yarhl.IO.html"><code>Yarhl.IO</code></a> (IO stands for <em>Input/Output</em>), which is similar to
.NET standard <code>System.IO</code> but with specific features to work with binary files.</p>
<p>This module is divided into binary and text files. Easy-peasy! Let's go deeper
into these classes!</p>
<h3 id="datastream">DataStream</h3>
<p><a class="xref" href="../api/Yarhl.IO.DataStream.html"><code>DataStream</code></a> wraps any kind of .NET <code>Stream</code>.</p>
<h4 id="reuse-of-stream">Reuse of Stream</h4>
<p>It allows to reuse a parent <code>Stream</code> to have substreams to reduce the number of
resources to use. For instance, to unpack a file you would just need to create
<code>DataStream</code> instances from the same parent <code>DataStream</code> having different
offsets and lengths.</p>
<p>Disposing the last instance of a <code>DataStream</code> that has a reference to a <code>Stream</code>
will dispose the <code>Stream</code> too.</p>
<h4 id="comparison">Comparison</h4>
<p>The <code>DataStream</code> class provides the
<a class="xref" href="../api/Yarhl.IO.DataStream.html#Yarhl_IO_DataStream_Compare_System_IO_Stream_"><code>Compare</code></a> method to
check if two streams are identical.</p>
<h4 id="push-and-pop-positions">Push and pop positions</h4>
<p>Similar to the terminal commands <code>pushd</code> and <code>popd</code>, our <code>DataStream</code> provides
methods for moving temporarily to a position to perform an operation and then
restore the position. This is very useful when you need to read or write a few
fields in another section of the file. It works with an stack so you can push
several positions.</p>
<ul>
<li><a class="xref" href="../api/Yarhl.IO.DataStream.html#Yarhl_IO_DataStream_PushCurrentPosition"><code>PushCurrentPosition</code></a>: save
the current position.</li>
<li><a class="xref" href="../api/Yarhl.IO.DataStream.html#Yarhl_IO_DataStream_PushToPosition_"><code>PushToPosition</code></a>: save the current
position and move.</li>
<li><a class="xref" href="../api/Yarhl.IO.DataStream.html#Yarhl_IO_DataStream_PopPosition"><code>PopPosition</code></a>: restore the last saved
position.</li>
<li><a class="xref" href="../api/Yarhl.IO.DataStream.html#Yarhl_IO_DataStream_RunInPosition_System_Action_System_Int64_Yarhl_IO_SeekMode_"><code>RunInPosition</code></a>:
push, run the lambda expression and pop again.</li>
</ul>
<h4 id="read-and-write">Read and Write</h4>
<p>We have also the typical read and write methods for arrays of bytes. And don't
forget about the <a class="xref" href="../api/Yarhl.IO.DataStream.html#Yarhl_IO_DataStream_WriteTo_System_String_"><code>WriteTo</code></a>
methods that allows to write a full <code>DataStream</code> in another <code>DataStream</code> or in a
file in your disk. Very useful mate!</p>
<h3 id="datareader-and-datawriter">DataReader and DataWriter</h3>
<p><a class="xref" href="../api/Yarhl.IO.DataReader.html"><code>DataReader</code></a> is the equivalent of the .NET
<code>BinaryReader</code> and <a class="xref" href="../api/Yarhl.IO.DataWriter.html"><code>DataWriter</code></a> of `BinaryWriter.
Apart from the typical read and write methods, they provide the following very
useful features.</p>
<h4 id="endianness">Endianness</h4>
<p>By properties or constructor you can specify if the endianness of the stream is
little or big. This will affect to all the read and write operations.</p>
<h4 id="strings">Strings</h4>
<p>By using the different overloads of <code>ReadString</code> and <code>Write</code> you can read and
write strings with different encodings, fixed sizes, null terminated or not or
in the format <em>size + content</em> style. I recommend you to take a look into them,
they cover most of the cases you will need to work with files.</p>
<h4 id="padding">Padding</h4>
<p>Are you tired of writing logic to skip or write padding bytes? Well, we too! If
you are reading a file and you want to skip padding bytes, you can call
<a class="xref" href="../api/Yarhl.IO.DataReader.html#Yarhl_IO_DataReader_SkipPadding_System_Int32_"><code>SkipPadding</code></a> and if you
need to write padding bytes, then
<a class="xref" href="../api/Yarhl.IO.DataWriter.html#Yarhl_IO_DataWriter_WritePadding_System_Byte_System_Int32_"><code>WritePadding</code></a>
will be your friend.</p>
<h3 id="textdatareader-and-textdatawriter">TextDataReader and TextDataWriter</h3>
<p>So far, <code>DataReader</code> and <code>DataWriter</code> have been very useful when you are dealing
with a file that contains some integer fields for size or offset, arrays of
bytes and maybe null-terminated strings. But, what about if you need to work
with a file that only contains text and you are interested in reading line by
line? In that case, you need <a class="xref" href="../api/Yarhl.IO.TextDataReader.html"><code>TextDataReader</code></a>
and <a class="xref" href="../api/Yarhl.IO.TextDataWriter.html"><code>TextDataWriter</code></a>.</p>
<h4 id="new-lines">New lines</h4>
<p>By default, <code>TextDataWriter</code> uses always (Windows too) the new line <code>\n</code>. It
doesn't use <code>\r\n</code>. The reason is that most file formats uses <code>\n</code> and in some
games having the <code>\r</code> may crash. It's sometimes difficult to notice that. If you
want to use any other new line string (you can even use <code>&lt;br/&gt;</code>), you just need
to change the <a class="xref" href="../api/Yarhl.IO.TextDataWriter.html#Yarhl_IO_TextDataWriter_NewLine"><code>NewLine</code></a> property.</p>
<p>In the case of the <code>TextDataReader</code> the behavior is different. The default value
for the <a class="xref" href="../api/Yarhl.IO.TextDataReader.html#Yarhl_IO_TextDataReader_NewLine"><code>NewLine</code></a> property depends on
the OS (Windows: <code>\r\n</code>, Unix: <code>\n</code>). In addition, we provided with an automatic
mechanism enabled by default:
<a class="xref" href="../api/Yarhl.IO.TextDataReader.html#Yarhl_IO_TextDataReader_AutoNewLine_"><code>AutoNewLine</code></a>. If it's enabled, you
don't need to know the line ending in advance because we will stop at <code>\n</code> and
remove the last <code>\r</code> if present. This is also useful if a file mix both line
endings. And remember, by setting the <code>NewLine</code> property <code>AutoNewLine</code> is
disabled.</p>
<h4 id="encoding">Encoding</h4>
<p>The encoding can only by specified in the constructor. We believe that it
doesn't have sense to change the encoding once you start using the reader
because a text file must not mix encodings.</p>
<h4 id="peeking">Peeking</h4>
<p>Do you need to read a line without actually moving the position of the stream?
Maybe you want to check if the line contains a token but you are not sure and
don't want to keep the current position all the time. Well, in that case you
have the <code>Peek*</code> methods.</p>
<h4 id="preambles--bom">Preambles / BOM</h4>
<p>Some encodings may have a specific
<a href="https://en.wikipedia.org/wiki/Byte_order_mark">BOM</a> (<em>Byte Order Mark</em>) (or
<em>preamble</em> in the .NET world). These are some bytes at the beginning of the
stream that confirms the encoding of the file. For instance, when using UTF-16,
the file will begin with the bytes <code>0xFEFF</code>. It also specifies if the encoding
is little-ending or big-endian (needed for UTF-16).</p>
<p>Our <code>TextDataReader</code> will skip the BOM (<em>if it's present</em>) at the beginning of
the file. In the case of the <code>TextDataWriter</code>, the behavior is defined by the
property <a class="xref" href="../api/Yarhl.IO.TextDataWriter.html#Yarhl_IO_TextDataWriter_AutoPreamble"><code>AutoPreamble</code></a> which is
set to <code>false</code> by default (again, some games may see it as unexpected bytes).
When enabled, the first write call will also write the BOM. You can also write
it manually by calling
<a class="xref" href="../api/Yarhl.IO.TextDataWriter.html#Yarhl_IO_TextDataWriter_WritePreamble"><code>WritePreamble()</code></a> (but remember,
only if you are at the beginning of the stream).</p>
<p>I know... I talk too much... Let's continue!</p>
<h3 id="examples">Examples</h3>
<h4 id="reading--writing-a-binary-file">Reading / writing a binary file</h4>
<pre><code class="lang-csharp">public void LoadFile(string path)
{
    using (var stream = DataStreamFactory.FromFile(path, FileOpenMode.Read)) {
        var reader = new DataReader(stream) {
            DefaultEncoding = new EscapeOutRangeEncoding(&quot;ascii&quot;),
            Endianness = EndiannessMode.BigEndian,
        };

        string id = reader.ReadString(4);
        int offset = reader.ReadInt32();
        reader.SkipPadding(32);
        double myDouble = reader.ReadDouble();

        string name;
        stream.RunInPosition(
            () =&gt; name = reader.ReadString(),
            offset);
    }
}

public void SaveFile(string path)
{
    using (var stream = DataStreamFactory.FromFile(path, FileOpenMode.Read)) {
        var writer = new DataWriter(stream);

        writer.Write(&quot;TEX0&quot;, false);
        writer.Write(0xCAFE);
        writer.Write(0x00);
        writer.WritePadding(0xFF, 32);
        writer.Write(&quot;My long text of 80 bytes&quot;, 80);

        stream.PushToPosition(0x08);
        writer.Write(0x65402);
        stream.PopPosition();
    }
}
</code></pre>
<h4 id="reading--writing-a-text-file">Reading / writing a text file</h4>
<pre><code class="lang-csharp">public void LoadFile(DataStream stream)
{
    var reader = new TextDataReader(stream, Encoding.Unicode);

    string firstLine = reader.ReadLine();
    char[] someChars = reader.Read(4);
    string beforeToken = reader.ReadToToken(&quot;#&quot;);

    if (reader.Peek() == ':')
        reader.ReadLine();
    string restFile = reader.ReadToEnd();
}

public void SaveFile(DataStream stream)
{
    var writer = new TextDataWriter(stream) {
        AutoPreamble = true,
    };

    writer.WriteLine(&quot;Hello world!&quot;);
    writer.WriteLine(&quot;Count is {0}&quot;, 42);
    writer.Write(&quot;No new line&quot;);
}
</code></pre>
<h2 id="implementing-file-formats">Implementing file formats</h2>
<p>Every game contains many files, which have a specific formats. For example files
with extension <code>.nclr</code> are a palettes, or <code>.aar</code> are a package files. Yarhl
helps you to code type as you were actually coding a game format.</p>
<p>To implement a file format, you just need to create a new class that implements
the (empty) <a class="xref" href="../api/Yarhl.FileFormat.IFormat.html"><code>IFormat</code></a> interface. In this class
you just need to add the fields of your format. In more programming terms, your
format it's just a data model.</p>
<p>Let's go for a quick example! Take a look into the following bytes from a file
that seems to have text from a game menu:</p>
<p><img src="../images/hex_example.png" alt="Hex view of example file"></p>
<p>This file seems to follow the following specification in little endian:</p>
<table>
<thead>
<tr>
<th>Size</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>Magic ID</td>
</tr>
<tr>
<td>2</td>
<td>Number of sentences</td>
</tr>
<tr>
<td>2</td>
<td>Size of the file</td>
</tr>
<tr>
<td>*</td>
<td>Null-terminated sentences</td>
</tr>
</tbody>
</table>
<p>So given this format, we would implement the following class that maps the
specification:</p>
<pre><code class="lang-csharp">public class MenuSentences : IFormat
{
    public MenuSentences()
    {
        Sentences = new Collection&lt;string&gt;();
    }

    public uint MagicID { get; set; }

    public ushort FileSize { get; set; }

    public Collection&lt;string&gt; Sentences { get; private set; }
}
</code></pre>
<p>Easy! Don't worry about how to convert that format, we will talk about that
later.</p>
<h3 id="binaryformat">BinaryFormat</h3>
<p><a class="xref" href="../api/Yarhl.IO.BinaryFormat.html"><code>BinaryFormat</code></a> is the most basic format since it
just represents raw bytes, a stream. It's... a <em>binary format</em>. This format is
assigned automatically when we open a file from Yarhl as we will see later.</p>
<p>Its only property <a class="xref" href="../api/Yarhl.IO.BinaryFormat.html#Yarhl_IO_BinaryFormat_Stream_"><code>Stream</code></a> allows you to
access to its inner stream.</p>
<h3 id="nodecontainerformat">NodeContainerFormat</h3>
<p>You may wonder... what about package formats like <code>.zip</code>? They are represented
with the format (or by inheriting it)
<a class="xref" href="../api/Yarhl.FileSystem.NodeContainerFormat.html"><code>NodeContainerFormat</code></a>. This format
contains a root folder, also known as <code>Node</code>. So let's see what a <code>Node</code> is.</p>
<h2 id="entering-the-virtual-world-nodes">Entering the virtual world: Nodes</h2>
<p>This is the main feature of Yarhl and the most important one, no doubt, 10/10
Yarhl users would say so<sup>1</sup>. Yarhl has a virtual file system to handle
your files while maintaining your computer intact, you can now delete your
&quot;tests&quot; folder and clean your desktop after-ages.</p>
<p><sup>1</sup> <small>None of Yarhl users wants to talk with me anymore. This may
not be 100% accurate.</small></p>
<h3 id="nodes">Nodes</h3>
<p>A <a class="xref" href="../api/Yarhl.FileSystem.Node.html"><code>Node</code></a> is a virtual file. It's like having a
file system with files and folder but only in memory for the duration of your
program. You can dynamically add and remove files / folders. These files and
folders are called nodes in Yarhl.</p>
<p>A node may have child nodes like a folder may have folders and files. You can
add the <em>subnodes</em> with the
<a class="xref" href="../api/Yarhl.FileSystem.NavigableNode-1.html#Yarhl_FileSystem_NavigableNode_1_Add__0_"><code>Add</code></a> method and you iterate
and access to its children with the
<a class="xref" href="../api/Yarhl.FileSystem.NavigableNode-1.html#Yarhl_FileSystem_NavigableNode_1_Children"><code>Children</code></a> property.</p>
<p>The node <a class="xref" href="../api/Yarhl.FileSystem.NavigableNode-1.html#Yarhl_FileSystem_NavigableNode_1_Name"><code>Name</code></a> must be unique.
You can also get the full path to the node in this new virtual filesystem. That
is, if you have a <em>root</em> node with name <code>MyRoot</code> and you add a node <code>Node1</code>, the
<a class="xref" href="../api/Yarhl.FileSystem.NavigableNode-1.html#Yarhl_FileSystem_NavigableNode_1_Path"><code>Path</code></a> property for <code>Node1</code> will
be <code>/MyRoot/Node1</code>.</p>
<p>Ah, one more thing before I forget. Regular files in your disk have some bytes
associated, right? Well, in the case of nodes they have a
<a href="#implementing-file-formats">Format</a> that we were talking before. That is, it
doesn't have to have bytes but it could be a type to represent image, texture,
text, font, ... The actual type of the node. For instance, let's say we create a
node from a disk file, it will have a <code>BinaryFormat</code> because for now it's just a
bunch of bytes. But if those bytes store a set of menu texts, we could transform
its format and associate its actual content type: <code>MenuSentences</code>. To the node
<a class="xref" href="../api/Yarhl.FileSystem.Node.html#Yarhl_FileSystem_Node_Format_"><code>Format</code></a> property you can set any type
that implements the <a class="xref" href="../api/Yarhl.FileFormat.IFormat.html"><code>IFormat</code></a> interface.</p>
<p>By the way, there is a property to get the inner <code>DataStream</code> when the format of
the node is a <code>BinaryFormat</code>: <a class="xref" href="../api/Yarhl.FileSystem.Node.html#Yarhl_FileSystem_Node_Stream"><code>Stream</code></a>. It
will return <code>null</code> if the type is not <code>BinaryFormat</code>. We added it because to do
cool things like:</p>
<pre><code class="lang-csharp">node.Stream.WriteTo(&quot;/home/mister_yarhl/my_node.bin&quot;);
</code></pre>
<p>If the type is different, you may want to check the method
<a class="xref" href="../api/Yarhl.FileSystem.Node.html#Yarhl_FileSystem_Node_GetFormatAs__1"><code>GetFormatAs&lt;T&gt;()</code></a>.</p>
<h3 id="why-nodes">Why nodes?</h3>
<p>Well, imagine that you have a Nintendo DS game <code>.nds</code>, you could open it with
Yarhl and access to its files and folders without actually extracting the files
in your disk. All access would be in memory, probably even sharing the same
stream thanks to the <code>sub-DataStreams</code>.</p>
<h3 id="files-vs-folders">Files vs folders</h3>
<p>As said, folders in our virtual file system are also nodes. They always have the
<code>NodeContainerFormat</code> or any class that inherits it. This format is just a root
node folder that becomes the children of the node. You can use the property
<a class="xref" href="../api/Yarhl.FileSystem.Node.html#Yarhl_FileSystem_Node_IsContainer_"><code>IsContainer</code></a> to check if the node is
a node container, that is, if it's a folder.</p>
<p>It's more clear with a picture:</p>
<p><img src="../images/node_example.png" alt="A directory named with tho files inside"></p>
<p><code>mastering</code> would be our root node with format <code>NodeContainerFormat</code>. While
<code>example.example</code> and <code>example2.example</code> would be our two child nodes. By
default they will have a <code>BinaryFormat</code> format.</p>
<h3 id="navigating-the-sea-of-nodes">Navigating the sea of nodes</h3>
<p>Do you have many nodes? I guess it will be difficult to navigate through all of
them. Then, you want to review the class
<a class="xref" href="../api/Yarhl.FileSystem.Navigator.html"><code>Navigator</code></a>. It provides with features like
iterators and finders.</p>
<p>To iterate over the node children you would just do:</p>
<pre><code class="lang-csharp">foreach (var node in root.Children) {
    // Something
}
</code></pre>
<p>But if you want to iterate over the full tree of nodes, that is, including the
children of your children (like <code>node</code> in the above example), you can use the
<code>Navigator</code>.</p>
<pre><code class="lang-csharp">foreach (var node in Navigator.IterateNodes(root)) {
    // Something
}
</code></pre>
<p>You can even specify how to do the iteration: going first deeper into each node
(<a href="https://en.wikipedia.org/wiki/Depth-first_search"><em>depth-first search</em></a>) or
getting first every children from the current node
(<a href="https://en.wikipedia.org/wiki/Breadth-first_search"><em>breadth-first search</em></a>).</p>
<p>If you just want to search a specific node given a full path, you want to use
<a class="xref" href="../api/Yarhl.FileSystem.Navigator.html#Yarhl_FileSystem_Navigator_SearchNode__1___0_System_String_"><code>Navigator.SearchNode(path)</code></a>.</p>
<h3 id="creating-the-file-system">Creating the file system</h3>
<p>So you want to start using node right now, eh. Well, it will be easy. You will
want to check out the static helper class:
<a class="xref" href="../api/Yarhl.FileSystem.NodeFactory.html"><code>NodeFactory</code></a>. Let's check some of its
methods:</p>
<pre><code class="lang-csharp">// Manual
var node1 = new Node(&quot;name&quot;, new BinaryFormat(filePath));

// Factory
var node2 = NodeFactory.FromFile(filePath);  // Node name is the file name
</code></pre>
<p>So, what about creating a node from a folder you would say.</p>
<pre><code class="lang-csharp">var emptyFolder = NodeFactory.CreateContainer(&quot;name&quot;);

var folderFromDisk = NodeFactory.FromDirectory(folderPath);
</code></pre>
<p>Yeeeah! That's the face I was looking for! You can create a virtual file that
quick!</p>
<p>Don't forget to review the overloads and the method
<a class="xref" href="../api/Yarhl.FileSystem.NodeFactory.html#Yarhl_FileSystem_NodeFactory_FromMemory_System_String_"><code>FromMemory</code></a> to
create a node with data in memory.</p>
<p>Yarhl is way more interesting now, right!?</p>
<h2 id="converters-putting-together-all-the-pieces">Converters: putting together all the pieces</h2>
<p>Finally! We have <em>formats</em>, <em>nodes</em> and some classes for <em>IO</em> operations. Now
everything begin to fall into place, you'll see.</p>
<p>Creating a tool to work with files usually require to work with different
formats, right? We need to convert from <code>.dat</code> to <code>.txt</code>, from <code>.bin</code> into a a
palette or unpacking several files from a <code>.pak</code> file.</p>
<p>Well, that's easy to do. Yarhl is all about converting formats, let's see an
example:</p>
<pre><code class="lang-csharp">public void ExportFontImage(string fontPath, string outputPath)
{
    using (var binary = new BinaryFormat(fontPath)) {
        var font = (Font)ConvertFormat.With&lt;Font2Binary&gt;(binary);
        var image = (Image)ConvertFormat.With&lt;Font2Image&gt;(font);
        image.Save(outputPath);
    }
}
</code></pre>
<ol>
<li>We start creating a new <code>BinaryFormat</code> from a file path.</li>
<li>We convert the <code>BinaryFormat</code> (reading its <code>Stream</code>) into a <code>Font</code> type.</li>
<li>We convert the <code>Font</code> format into an <code>Image</code> type.</li>
<li>We save it to a physical file in the hard-drive.</li>
</ol>
<p><em>&quot;But what's <code>Font2Binary</code> and <code>Font2Image</code>, <strong>Mister Yarhl</strong>?&quot;</em>, you would say.
They are <strong>converters</strong>! A converter is a class which implements the
<a class="xref" href="../api/Yarhl.FileFormat.IConverter-2.html">IConverter</a> interface.</p>
<p>You can check some converter examples from the tools to translate <em>Pokémon
Conquest</em>. For instance:
<a href="https://github.com/pleonex/PokemonConquest/blob/master/AmbitionConquest/AmbitionConquest/Fonts/Font2Binary.cs">Font2Binary</a>
and
<a href="https://github.com/pleonex/PokemonConquest/blob/master/AmbitionConquest/AmbitionConquest/Fonts/Font2Image.cs">Font2Image</a>.</p>
<h3 id="converting-formats">Converting formats</h3>
<p>But let's come back to our example of <code>MenuSentences</code> from the
<a href="#implementing-file-formats">format</a> section. It's turn to create a converter to
fill the <code>MenuSentences</code> class from a file. That it's to <em>read</em> a file with that
format.</p>
<pre><code class="lang-csharp">public class Binary2MenuSentences : IConverter&lt;BinaryFormat, MenuSentences&gt;
{
    public MenuSentences Convert(BinaryFormat source)
    {
        var menu = new MenuSentences();
        var reader = new DataReader(source.Stream);

        menu.MagicID = reader.ReadUInt32();
        ushort numSentences = reader.ReadUInt16();
        menu.FileSize = reader.ReadUInt16();

        for (int i = 0; i &lt; numSentences; i++) {
            menu.Sentences.Add(reader.ReadString());
        }

        return menu;
    }
}
</code></pre>
<p>So now we can get our menu instance with:</p>
<pre><code class="lang-csharp">public void ReadMenuFile(string filePath)
{
    using (var binary = new BinaryFormat(filePath)) {
        var menu = (MenuSentences)ConvertFormat.With&lt;Binary2MenuSentences&gt;(binary);
        // Do something with the menu instance
    }
}
</code></pre>
<p>Since there is just one converter <code>BinaryFormat -&gt; MenuSentences</code> we can
simplify it even more:</p>
<pre><code class="lang-csharp">public void ReadMenuFile(string filePath)
{
    using (var binary = new BinaryFormat(filePath)) {
        MenuSentences menu = ConvertFormat.To&lt;MenuSentences&gt;(binary);
        // Do something with the menu instance
    }
}
</code></pre>
<p>Do you want to write your <em>new</em> or <em>updated</em> menu instance? Let's write a
converter to convert from <code>MenuSentences</code> to <code>BinaryFormat</code> and save in a file
in disk.</p>
<pre><code class="lang-csharp">public class MenuSentences2Binary : IConverter&lt;MenuSentences, BinaryFormat&gt;
{
    public BinaryFormat Convert(MenuSentences menu)
    {
        var binary = new BinaryFormat();
        var writer = new DataWriter(binary.Stream);

        writer.Write(menu.MagicID);
        writer.Write((ushort)menu.Sentences.Count);
        writer.Write((ushort)0x00); // Placeholder size to override later

        foreach (string sentence in menu.Sentences) {
            writer.Write(sentence);
        }

        binary.Stream.Position = 0x06;
        writer.Write((ushort)binary.Stream.Length);

        return binary;
    }
}
</code></pre>
<p>And that's it! I'm pretty sure you've got enough of converters</p>
<h3 id="transforming-nodes">Transforming nodes</h3>
<p>Don't forget that a node can have a format. How do we <em>convert</em> the format from
a node? We could use the approach from before, but there are two methods that
will <strong>convert and update</strong> the format of the node:
<a class="xref" href="../api/Yarhl.FileSystem.Node.html#Yarhl_FileSystem_Node_TransformTo_"><code>TransformTo</code></a> and
<a class="xref" href="../api/Yarhl.FileSystem.Node.html#Yarhl_FileSystem_Node_TransformWith_"><code>TransformWith</code></a>. They will also
dispose the old format so we don't need to do anything, just transform several
times the format of our node until it's the one we want.</p>
<pre><code class="lang-csharp">var node = NodeFactory.FromFile(path);
node.TransformTo&lt;MenuSentences&gt;;

// Now node.Format is MenuSentences
</code></pre>
<p>or from the first example:</p>
<pre><code class="lang-csharp">public void ExportFontImage(string fontPath, string outputPath)
{
    using (var node = NodeFactory.FromFile(fontPath)) {
        node.TransformWith&lt;Font2Binary&gt;()
            .TransformWith&lt;Font2Image&gt;();

        node.GetFormatAs&lt;Image&gt;().Save(outputPath);
    }
}
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/SceneGate/Yarhl/blob/develop/docs/guides/Yarhl-nutshell.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright (c) 2018 SceneGate
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
